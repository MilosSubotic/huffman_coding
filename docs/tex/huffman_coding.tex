%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[12pt, a4paper]{article}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Packages.

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage[serbian]{babel}

\usepackage{indentfirst}

\usepackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{decorations.markings}
\usetikzlibrary{shapes}
\usetikzlibrary{calc,arrows}
\usetikzlibrary{arrows,automata}

\usepackage{pgf}
\usepackage{amsmath}

\usepackage{graphicx}

\usepackage{listings}
\usepackage{color}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
 
% Use Courier font to have tt and bf together.
\renewcommand{\ttdefault}{pcr}
\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\footnotesize\ttfamily\bfseries,
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b,
	keepspaces=true,
	numbers=left,
	numbersep=5pt,
	showspaces=false,          
	showstringspaces=false,
	showtabs=false,
	tabsize=4
}
 
\lstset{style=mystyle}

% Inline listing.
\def\il#1{\begin{lstinline}[language=VHDL]{#1}\end{lstinline}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\makeatletter

\newcommand{\gettikzxy}[3]{%
  \tikz@scan@one@point\pgfutil@firstofone#1\relax
  \edef#2{\the\pgf@x}%
  \edef#3{\the\pgf@y}%
}

% Data Flip Flip (DFF) shape
\pgfdeclareshape{dff}{
  % The 'minimum width' and 'minimum height' keys, not the content, determine
  % the size
  \savedanchor\northeast{%
    \pgfmathsetlength\pgf@x{\pgfshapeminwidth}%
    \pgfmathsetlength\pgf@y{\pgfshapeminheight}%
    \pgf@x=0.5\pgf@x
    \pgf@y=0.5\pgf@y
  }
  % This is redundant, but makes some things easier:
  \savedanchor\southwest{%
    \pgfmathsetlength\pgf@x{\pgfshapeminwidth}%
    \pgfmathsetlength\pgf@y{\pgfshapeminheight}%
    \pgf@x=-0.5\pgf@x
    \pgf@y=-0.5\pgf@y
  }
  % Inherit from rectangle
  \inheritanchorborder[from=rectangle]

  % Define same anchor a normal rectangle has
  \anchor{center}{\pgfpointorigin}
  \anchor{north}{\northeast \pgf@x=0pt}
  \anchor{east}{\northeast \pgf@y=0pt}
  \anchor{south}{\southwest \pgf@x=0pt}
  \anchor{west}{\southwest \pgf@y=0pt}
  \anchor{north east}{\northeast}
  \anchor{north west}{\northeast \pgf@x=-\pgf@x}
  \anchor{south west}{\southwest}
  \anchor{south east}{\southwest \pgf@x=-\pgf@x}
  \anchor{text}{
    \pgfpointorigin
    \advance\pgf@x by -.5\wd\pgfnodeparttextbox%
    \advance\pgf@y by -.5\ht\pgfnodeparttextbox%
    \advance\pgf@y by +.5\dp\pgfnodeparttextbox%
  }

  % Define anchors for signal ports
  \anchor{D}{
    \pgf@process{\northeast}%
    \pgf@x=-1\pgf@x%
    \pgf@y=.5\pgf@y%
  }
  \anchor{CLK}{
    \pgf@process{\northeast}%
    \pgf@x=-1\pgf@x%
    \pgf@y=-.66666\pgf@y%
  }
  \anchor{Q}{
    \pgf@process{\northeast}%
    \pgf@y=.5\pgf@y%
  }
  \anchor{nR}{
    \pgf@process{\northeast}%
    \pgf@x=0pt%
    \pgf@y=-\pgf@y%
  }
  % Draw the rectangle box and the port labels
  \backgroundpath{
    % Rectangle box
    \pgfpathrectanglecorners{\southwest}{\northeast}
    % Angle (>) for clock input
    \pgf@anchor@dff@CLK
    \pgf@xa=\pgf@x \pgf@ya=\pgf@y
    \pgf@xb=\pgf@x \pgf@yb=\pgf@y
    \pgf@xc=\pgf@x \pgf@yc=\pgf@y
    \pgfmathsetlength\pgf@x{1.6ex} % size depends on font size
    \advance\pgf@ya by \pgf@x
    \advance\pgf@xb by \pgf@x
    \advance\pgf@yc by -\pgf@x
    \pgfpathmoveto{\pgfpoint{\pgf@xa}{\pgf@ya}}
    \pgfpathlineto{\pgfpoint{\pgf@xb}{\pgf@yb}}
    \pgfpathlineto{\pgfpoint{\pgf@xc}{\pgf@yc}}
    \pgfclosepath

    % Draw port labels
    \begingroup
    \tikzset{flip flop/port labels} % Use font from this style
    \tikz@textfont

    \pgf@anchor@dff@D
    \pgftext[left,base,at={\pgfpoint{\pgf@x}{\pgf@y}},x=\pgfshapeinnerxsep]{\raisebox{-0.75ex}{D}}

    \pgf@anchor@dff@Q
    \pgftext[right,base,at={\pgfpoint{\pgf@x}{\pgf@y}},x=-\pgfshapeinnerxsep]{\raisebox{-.75ex}{Q}}

    \pgf@anchor@dff@nR
    \pgftext[bottom,at={\pgfpoint{\pgf@x}{\pgf@y}},y=\pgfshapeinnerysep]{nR}
    \endgroup
  }
}

% Key to add font macros to the current font
\tikzset{add font/.code={\expandafter\def\expandafter\tikz@textfont\expandafter{\tikz@textfont#1}}} 

% Define default style for this node
\tikzset{flip flop/port labels/.style={font=\sffamily\scriptsize}}
\tikzset{every dff node/.style={draw,minimum width=2cm,minimum 
height=2.828427125cm,very thick,inner sep=1mm,outer sep=0pt,cap=round,add 
font=\sffamily}}

\tikzstyle{comb_log_cloud} = [
	cloud, draw, cloud puffs=10, cloud puff arc=120, aspect=2, align=center
]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Commands.

\newcommand{\engl}[1]{(engl. {#1})}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Osnove računarske tehnike - LPRS \\
Vežba 4 \\
Napredne sekvencijalne mreže \\
Huffman kodovanje
}
\author{Miloš Subotić}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Uvod}
Projektovanje kompleksnijih sekvencijalnih mreža će biti prikazano na primeru realizacije
Huffman kodovanja za statističku kompresiju podataka.

%\section{Huffman kodovanje}

\section{Automati}
Automat sa konačnim brojem stanja je generalizovana sekvencijalna mreža,
pogodnog oblika za projektovanje.
Automat se sastoji od registra koji čuva trenutno stanje automata $state$,
funkcije prelaza koja je kombinaciona mreža za određivanje narednog stanja $next\_state$
na osnovu ulaza $i\_x$ odnosno $x$ i trenutnog stanja $state$,
i izlazne funkcije koja je kombinaciona mreža za određivanje izlaza $o\_y$
na osnovu ulaza $i\_x$ odnosno $x$ i trenutnog stanja $state$.
Blok šema automata je prikazana na Slici~\ref{fig:fsm_block_sch}.


\begin{figure}[h]
	\centering
	\advance\leftskip-2cm
	\begin{tikzpicture}
		\node [draw,thick,minimum width=14cm,minimum height=7cm] (frame) at (-1, 0.5) {};
		
			
		\node [dff] (reg) at (0, -0.7) {Register};
		\node [comb_log_cloud] (trans_fun) at(-5, 0) {Transfer \\ function};
		\node [comb_log_cloud] (out_fun) at(4, 0) {Output \\ function};
		\node at ([xshift=1.5cm]out_fun.east) (o_y) {$o\_y$};
		\gettikzxy{(trans_fun.west)}{\x}{\y}
		\node [left] at (-8.5, \y) (i_x) {$i\_x$};
		\gettikzxy{(reg.CLK)}{\x}{\y}
		\node [left] at (-8.5, \y) (i_clk) {$i\_clk$};
		\node [left] at (-8.5, -2.5) (in_rst) {$in\_rst$};
		
		\draw [->] (trans_fun.east) -- node[below] {$next\_state$}  ++(2.0, 0) -- (reg.D);
		\draw [->] (reg.Q) -- node (reg_node) {\textbullet} node[below] {$state$} ++(1, 0) -- (out_fun.west);		
		\draw [->] (reg_node.center) -- ++(0, 2.5) -- node[below] {$state$} ++(-6, 0) -| (trans_fun.north);
		
		\draw [->] (i_x) --  node (x_node) {\textbullet} node[below] {$x$} ++(2.5, 0) -- (trans_fun.west);
		\draw [->] (x_node.center) -- ++(0, 3.5) -- node[below] {$x$} ++(8, 0) -| (out_fun.north);
		
		\draw [->] (i_clk) -- (reg.CLK);
		\draw [->] (in_rst) -| (reg.nR);
		\draw [->] (out_fun.east) -- (o_y);
		
	\end{tikzpicture}
	\caption{Automat}
	\label{fig:fsm_block_sch}
\end{figure}

\par
Neka je na primer potrebno izraditi osnovni automat za rešenje zadatka 
koji će vršiti prihvat podataka sa AXI Stream magistrale, 
davati 4-bitne simbole na izlazu,
upravljati kontrolne signale,
upravljati brojačem faze.
Na Slici~\ref{fig:basic_fsm} je prikazan diagram stanja automata.


\begin{figure}[h]
	\centering
	\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=5cm]
		\node[initial,state,align=center] (NEW_CHAR) {NEW \\ CHAR};
		\node[state,align=center]         (UPPER_NIBBLE) [right of=NEW_CHAR] {UPPER \\ NIBBLE};
		\node[state,align=center]         (LAST_STAGE) [above of=UPPER_NIBBLE] {LAST \\ STAGE};

		\path[->]
			(NEW_CHAR) edge [bend right] node[below] {\il{s_axis_tvalid = '1'}} (UPPER_NIBBLE)
			(UPPER_NIBBLE) edge [bend right] (NEW_CHAR)
			(UPPER_NIBBLE) edge [bend right] node[left] {\il{stage = 15}} (LAST_STAGE)
			(LAST_STAGE) edge [bend right] (NEW_CHAR);
		
	\end{tikzpicture}
	\caption{Osnovni automat za rešenje zadatka}
	\label{fig:basic_fsm}
\end{figure}

\par
Početno stanje je \il{NEW_CHAR}. 
U tom stanju izlaz \il{s_axis_tready} je postavljen na 1 što govori spoljnom rukovaocu \engl{Bus Master}
da je primalac spreman za prihvat podataka \engl{Bus Slave}.
U tom stanju se očekuje da je signal \il{s_axis_tvalid} posavljen na 1
što označava da je novi bajt postavljen na \il{s_axis_tdata}.
Kada su postavljeni \il{s_axis_tvalid} i \il{s_axis_tready} na 1 to je znak za rukovaoca i primaoca da je podatak preuzet.
Kada je automat u stanju \il{NEW_CHAR} na \il{o_sym} se prosleđuju donja 4 biti ulaznog bajta.
Kada je automat u stanju \il{NEW_CHAR} i \il{s_axis_tvalid} posavljen na 1 potrebno je sačuvati gornja 4 bita ulaznog bajta,
koji će biti prosleđeni na \il{o_sym} u idućem taktu.
\par
Kada je \il{s_axis_tvalid} posavljen na 1, što je prikazano na luku na Slici~\ref{fig:basic_fsm}, 
prelazi se u stanje \il{UPPER_NIBBLE}.
Sada se \il{s_axis_tready} postavlja na 0 kako bi zaustavili prihvat podataka sa AXI Stream magistrale,
jer još nismo prosledili gornji simbol.
U tom stanju na \il{o_sym} izlaz se prosleđuje gornji simbol.
Iz to tog stanja se uobičajeno prelazi ponovo u \il{NEW_CHAR}, 
ali ako je brojač faze \il{stage} 15 potrebno je preći u stanje \il{LAST_STAGE}.
\par
\il{LAST_STAGE} stanje služi da se potroši jedan takt viška dok je brojač faze \il{stage} jednak 16.
Kada je brojač faze \il{stage} 16 onda se podaci iz jednog bloka obrade prosleđuju u drugi blok obrade. 
Iz ovog stanja se prelazi direktno u \il{NEW_CHAR}. 
\par
Za realizaciju prvo je potrebno definisati tip sa enumerisanim stanjima automata,
kao na Listingu~\ref{lst:enum_def}.

\lstinputlisting[float, caption={Tip sa enumerisanim stanjima automata},label={lst:enum_def},language=VHDL]{listings/enum_def.vhd}


\par
Naredni deo je definisanje signala potrebnih za automat kao na Listingu~\ref{lst:fsm_signals}.
Ovi signali će biti tipa \il{t_states}.
Za početak su definisani samo trenutno stanje \il{state} i naredno stanje \il{next_state},
ali moguće je po potrebi definisati i još neke signale.

\lstinputlisting[float, caption={Tip sa enumerisanim stanjima automata},label={lst:fsm_signals},language=VHDL]{listings/fsm_signals.vhd}


\par
Dalje je potrebno definisati registar za čuvanje stanja automata. 
VHDL sintaksa za definisanje registra je data na Listingu~\ref{lst:fsm_reg}.
Linija \il{state <= NEW_CHAR;} postavlja početno stanje kada je reset aktivan (\il{in_rst = '0'}).
Linija \il{state <= next_state;} označava da je ulaz registra \il{next_state} sačuvan na rastuću ivicu takta (\il{rising_edge(i_clk)}).
Izlaz registra je \il{state}.

\lstinputlisting[float, caption={Registar stanja automata},label={lst:fsm_reg},language=VHDL]{listings/fsm_reg.vhd}

\par
Funkcija prelaza i izlaza se realizuju kao klasične kombinacione mreže. 
Praktičano je praviti multiplekser \il{with state select} i po trenutnom stanju određivati koji prosleđivati konkretnu vrednost
ili izračunat signal.

\par
\il{o_sym} je multipleksiran na donja 4 bita ulaznog podatka u \il{NEW_CHAR}, 
dok je u stanju \il{UPPER_NIBBLE} postavljen na gornja 4 bita sačuvana u registar u \il{NEW_CHAR} stanju.
\par
\il{o_pipe_en} signal bi trebao da je uvek posavljen na 1 sem u slučaju kad je trenutno stanje \il{NEW_CHAR}
i nema validnog ulaza tj. \il{s_axis_tvalid} je 0.

\par
Još je potrebno realizovati brojač faze da broji od 0 do 16.
Njegov signal dozvole se isto ponaša kao i \il{o_pipe_en}.

\section{Zadatak}
Na Slici~\ref{fig:full_fsm} je prikazan automat koji je potrebno implementirati u prvom bloku (\il{text2sym_conv_and_stage_cnt}).
Razlika u odnosu na automat sa slike Slici~\ref{fig:basic_fsm} je da postoje 2 nova stanja.
U stanje \il{UPPER_NIBBLE_LAST} se prelazi kada su \il{s_axis_tvalid} i \il{s_axis_tlast} postavljeni na 1.
\il{s_axis_tlast} označava da je na AXI Stream magistrali zadnji bajt zadnjeg bloka.
U \il{UPPER_NIBBLE_LAST} stanju se prosleđuje zadnji simbol na izlaz i prelazi se u \il{FLUSH} stanje,
u kom bi trebalo da se čeka sve dok se celokupan sistem ne isprazni.
Dok je trenutno stanje \il{FLUSH} potrebno je postaviti izlaz \il{o_pipe_flush} na 1.
Iz stanja \il{FLUSH} bi trebalo izaći nakon nekoliko ciklusa od 17 taktova.
Zasad to nije bitno realizovati jer još nema dovoljno blokova obrade koji zahtevaju pražnjenje.

\begin{figure}[h]
	\centering
	\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=5cm]
		\node[initial,state,align=center] (NEW_CHAR) {NEW \\ CHAR};
		\node[state,align=center]         (UPPER_NIBBLE) [right of=NEW_CHAR] {UPPER \\ NIBBLE};
		\node[state,align=center]         (LAST_STAGE) [above of=UPPER_NIBBLE] {LAST \\ STAGE};
		\node[state,align=center]         (FLUSH) [above of=NEW_CHAR] {FLUSH};
		\node[state,align=center]         (UPPER_NIBBLE_LAST) [left of=FLUSH] {UPPER \\ NIBBLE \\ LAST};

		\path[->]
			(NEW_CHAR) edge [bend right] node[below] {\il{s_axis_tvalid}} (UPPER_NIBBLE)
			(UPPER_NIBBLE) edge [bend right] (NEW_CHAR)
			(UPPER_NIBBLE) edge [bend right] node[left] {\il{stage = 15}} (LAST_STAGE)
			(LAST_STAGE) edge [bend right] (NEW_CHAR)
			(NEW_CHAR) edge [bend right] node[left] {\il{s_axis_tvalid and s_axis_tlast}} (UPPER_NIBBLE_LAST)
			(UPPER_NIBBLE_LAST) edge [bend left] (FLUSH)
			(FLUSH) edge (NEW_CHAR);
	\end{tikzpicture}
	\caption{Automat za rešenje zadatka}
	\label{fig:full_fsm}
\end{figure}

\par
Pored ovo ulaznog bloka potrebno je realizovati \il{histogram}.
\il{histogram} treba da broji koliko se koji simbol pojavio dok je \il{o_pipe_en}.
Kada je \il{i_stage} 16 proslediti  u naredni blok za sortiranje.
Koristiti tipove iz \textbf{\textit{global.vhd}} kao što su \il{t_sym} i \il{t_freq_array}.
\par
U bloku za sortiranje koristiti paralelizovani bubble sort algoritam za sortiranje.
Potrebno je naizmenično porediti i zamenjivati ako je potrebno elemente na sledeći način:
ako je parna faza (gledati najniži bit \il{i_stage} signala) onda porediti parove 0 i 1, 2 i 3, 4 i 5 itd.
dok ako je neparna faza porediti parove 1 i 2, 3 i 4, 5 i 6 itd.
Pogodno je koristiti strukturu \il{t_sym_and_freq} za lakšu realizaciju.
\par
Koristiti C++ model \textbf{\textit{huffman\_coding.cpp}},
ali pre svega \textbf{\textit{huffman\_coding.log}} kao zlatnu referencu za realizaciju algoritma.
C++ model i \textbf{\textit{huffman\_encoder\_tb.vhd}} imaju istu pobudu na ulazu,
tako da je moguće proveriti rezultate određenih blokova.
\par
Obavezna je izrada blok diagrama rešenja i po potrebi šemtaski diagram nekih blokova.
Nije potreban šematski diagram opštepoznatih blokova kao što je brojač.
Nije potrebno crtati kompletnu šemu za svih 16 elemenata, 
dovoljno je prikazati samo par njih a one između zamisliti da postoje i razdvojiti tačkicama.


\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
